import { hostname } from "os";
import { normalize as fileNormalize } from "path";
import { types, inspect } from "util";
import { formatTemplate } from "../../formatTemplate.js";
const meta = {
    runtime: "Nodejs",
    hostname: hostname(),
};
export function getMeta(logLevelId, logLevelName, stackDepthLevel, name, parentNames) {
    return {
        ...meta,
        name,
        parentNames,
        date: new Date(),
        logLevelId,
        logLevelName,
        path: getCallerStackFrame(stackDepthLevel),
    };
}
export function getCallerStackFrame(stackDepthLevel, error) {
    try {
        throw error == null ? new Error("getStackTrace") : error;
    }
    catch (e) {
        const line = e?.stack?.split("\n")?.filter((thisLine) => thisLine.includes("    at "))?.[stackDepthLevel];
        let fullFilePath = line?.replace(/^\s+at\s+/gm, "");
        if (fullFilePath?.slice(-1) === ")") {
            fullFilePath = fullFilePath?.match(/\(([^)]+)\)/)?.[1];
        }
        const errorStackLine = line?.split(" (");
        const pathArray = fullFilePath?.includes(":") ? fullFilePath?.replace("file://", "")?.replace(process.cwd(), "")?.split(":") : undefined;
        const fileColumn = pathArray?.pop();
        const fileLine = pathArray?.pop();
        const filePath = pathArray?.pop();
        const fileName = filePath?.split("/").pop();
        const filePathWithLine = fileNormalize(`${filePath}:${fileLine}`);
        return {
            fullFilePath,
            fileName,
            fileColumn,
            fileLine,
            filePath,
            filePathWithLine,
            method: errorStackLine?.[0],
        };
    }
}
export function getErrorTrace(error) {
    return error?.stack?.split("\n")?.reduce((result, line) => {
        if (line.includes("    at ")) {
            line = line.replace(/^\s+at\s+/gm, "");
            const errorStackLine = line.split(" (");
            const fullFilePath = line?.slice(-1) === ")" ? line?.match(/\(([^)]+)\)/)?.[1] : line;
            const pathArray = fullFilePath?.includes(":") ? fullFilePath?.replace("file://", "")?.replace(process.cwd(), "")?.split(":") : undefined;
            const fileColumn = pathArray?.pop();
            const fileLine = pathArray?.pop();
            const filePath = pathArray?.pop();
            const fileName = filePath?.split("/")?.pop();
            const filePathWithLine = fileNormalize(`${filePath}:${fileLine}`);
            if (filePath != null && filePath.length > 0) {
                result.push({
                    fullFilePath,
                    fileName,
                    fileColumn,
                    fileLine,
                    filePath,
                    filePathWithLine,
                    method: errorStackLine?.[1] != null ? errorStackLine?.[0] : undefined,
                });
            }
        }
        return result;
    }, []);
}
export function isError(e) {
    return types?.isNativeError != null ? types.isNativeError(e) : e instanceof Error;
}
export function prettyFormatLogObj(logObj, maskedArgs, settings) {
    return [logObj, ...maskedArgs].reduce((result, arg) => {
        isError(arg) ? result.errors.push(prettyFormatErrorObj(arg, settings)) : result.args.push(arg);
        return result;
    }, { args: [], errors: [] });
}
export function prettyFormatErrorObj(error, settings) {
    const errorStackStr = getErrorTrace(error).map((stackFrame) => {
        return formatTemplate(settings, settings.prettyErrorStackTemplate, { ...stackFrame }, true);
    });
    const placeholderValuesError = {
        errorName: ` ${error.name} `,
        errorMessage: error.message,
        errorStack: errorStackStr.join("\n"),
    };
    return formatTemplate(settings, settings.prettyErrorTemplate, placeholderValuesError);
}
export function transportFormatted(logMetaMarkup, logArgs, logErrors, settings) {
    const logErrorsStr = (logErrors.length > 0 && logArgs.length > 0 ? "\n" : "") + logErrors.join("\n");
    settings.prettyInspectOptions.colors = settings.stylePrettyLogs;
    logArgs = logArgs.map((arg) => (typeof arg === "object" ? inspect(arg, settings.prettyInspectOptions) : arg));
    console.log(logMetaMarkup + logArgs.join(" ") + logErrorsStr);
}
export function transportJSON(json) {
    console.log(jsonStringifyRecursive(json));
    function jsonStringifyRecursive(obj) {
        const cache = new Set();
        return JSON.stringify(obj, (key, value) => {
            if (typeof value === "object" && value !== null) {
                if (cache.has(value)) {
                    return "[Circular]";
                }
                cache.add(value);
            }
            return value;
        }, 2);
    }
}
export function isBuffer(arg) {
    return Buffer.isBuffer(arg);
}

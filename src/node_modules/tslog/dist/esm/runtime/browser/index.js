import { formatTemplate } from "../../formatTemplate.js";
import { inspect } from "./util.inspect.polyfil.js";
const meta = {
    runtime: "Browser",
    browser: window?.["navigator"].userAgent,
};
export function getMeta(logLevelId, logLevelName, stackDepthLevel, name) {
    return {
        ...meta,
        name,
        date: new Date(),
        logLevelId,
        logLevelName,
        path: getCallerStackFrame(stackDepthLevel),
    };
}
export function getCallerStackFrame(stackDepthLevel) {
    try {
        throw new Error("getStackTrace");
    }
    catch (e) {
        const href = window.location.origin;
        const error = e;
        if (error?.stack) {
            let fullFilePath = error?.stack
                ?.split("\n")
                ?.filter((line) => !line.includes("Error: "))?.[stackDepthLevel]?.replace(/^\s+at\s+/gm, "");
            if (fullFilePath?.slice(-1) === ")") {
                fullFilePath = fullFilePath?.match(/\(([^)]+)\)/)?.[1];
            }
            const pathArray = fullFilePath?.includes(":")
                ? fullFilePath
                    ?.replace("global code@", "")
                    ?.replace("file://", "")
                    ?.replace(href, "")
                    ?.replace(/^\s+at\s+/gm, "")
                    ?.split(":")
                : undefined;
            const fileColumn = pathArray?.pop();
            const fileLine = pathArray?.pop();
            const filePath = pathArray?.pop()?.split("?")?.[0];
            const fileName = filePath?.split("/").pop();
            const filePathWithLine = `${href}${filePath}:${fileLine}`;
            const errorStackLine = fullFilePath?.split(" (");
            return {
                fullFilePath,
                fileName,
                fileColumn,
                fileLine,
                filePath,
                filePathWithLine,
                method: errorStackLine?.[0],
            };
        }
        return {
            fullFilePath: undefined,
            fileName: undefined,
            fileColumn: undefined,
            fileLine: undefined,
            filePath: undefined,
            filePathWithLine: undefined,
            method: undefined,
        };
    }
}
export function getErrorTrace(error) {
    const href = window.location.origin;
    return error?.stack
        ?.split("\n")
        ?.filter((line) => !line.includes("Error: "))
        ?.reduce((result, line) => {
        if (line?.slice(-1) === ")") {
            line = line.match(/\(([^)]+)\)/)?.[1] ?? "";
        }
        line = line.replace(/^\s+at\s+/gm, "");
        const errorStackLine = line.split(" (");
        const fullFilePath = line?.slice(-1) === ")" ? line?.match(/\(([^)]+)\)/)?.[1] : line;
        const pathArray = fullFilePath?.includes(":")
            ? fullFilePath
                ?.replace("global code@", "")
                ?.replace("file://", "")
                ?.replace(href, "")
                ?.replace(/^\s+at\s+/gm, "")
                ?.split(":")
            : undefined;
        const fileColumn = pathArray?.pop();
        const fileLine = pathArray?.pop();
        const filePath = pathArray?.pop()?.split("?")[0];
        const fileName = filePath?.split("/")?.pop()?.split("?")[0];
        const filePathWithLine = `${href}${filePath}:${fileLine}`;
        if (filePath != null && filePath.length > 0) {
            result.push({
                fullFilePath,
                fileName,
                fileColumn,
                fileLine,
                filePath,
                filePathWithLine,
                method: errorStackLine?.[1] != null ? errorStackLine?.[0] : undefined,
            });
        }
        return result;
    }, []);
}
export function isError(e) {
    return e instanceof Error;
}
export function prettyFormatLogObj(logObj, maskedArgs, settings) {
    return [logObj, ...maskedArgs].reduce((result, arg) => {
        isError(arg) ? result.errors.push(prettyFormatErrorObj(arg, settings)) : result.args.push(arg);
        return result;
    }, { args: [], errors: [] });
}
export function prettyFormatErrorObj(error, settings) {
    const errorStackStr = getErrorTrace(error).map((stackFrame) => {
        return formatTemplate(settings, settings.prettyErrorStackTemplate, { ...stackFrame }, true);
    });
    const placeholderValuesError = {
        errorName: ` ${error.name} `,
        errorMessage: error.message,
        errorStack: errorStackStr.join("\n"),
    };
    return formatTemplate(settings, settings.prettyErrorTemplate, placeholderValuesError);
}
export function transportFormatted(logMetaMarkup, logArgs, logErrors, settings) {
    const logErrorsStr = (logErrors.length > 0 && logArgs.length > 0 ? "\n" : "") + logErrors.join("\n");
    settings.prettyInspectOptions.colors = settings.stylePrettyLogs;
    logArgs = logArgs.map((arg) => (typeof arg === "object" ? inspect(arg, settings.prettyInspectOptions) : arg));
    console.log(logMetaMarkup + logArgs.join(" ") + logErrorsStr);
}
export function transportJSON(json) {
    console.log(JSON.stringify(json, null, 2));
}
export function isBuffer(arg) {
    return undefined;
}
